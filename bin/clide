#!/usr/bin/env ruby
# vim: fdm=marker

require 'optparse'
require 'pp'
require 'psych'

require_relative '../lib/pom'

# Top level command to manage a maven java project from the command line.

#{{{
class Clide
  attr_accessor :conf
  
  def initialize
    @conf = ClideConfig.instance
  end

  #{{{
  def register_command(name, fn)
    if @commands.has_key? name
      puts "A command for #{name} already exists!  Aborting!"
      puts "If you really want to override the #{name} command, use register_command!()."
      false
    else
      $commands[name] = fn
      true
    end
  end
  #}}}

  ##
  # Generates import statements for all the provided keywords
  #{{{
  def gen_imports(keywords)
    puts "Not implemented"
  end
  #}}}

  #{{{
  def update_dependencies
    # determine dependencies and store them
    @conf[:dependencies][:file].open('w+') { |file|
      file.write Psych.dump @pom.dependencies
    }
  end
  #}}}

  #{{{
  def generate_classpaths
    # generate the classpath for each module
    @pom.modules.each { |_module|
      @conf[:classpath][_module.text] = Set.new if @conf[:classpath][_module.text].nil?

      @pom.dependencies[_module.text].each { |dep_coordinate|
        @conf[:classpath][_module.text] << @pom.dependencies[:all][dep_coordinate].get_path_to_dep
      }
    }
    @conf[:classpath][:file].open('w+') { |file| 
      file.write Psych.dump @conf[:classpath]
    }
  end
  #}}}

  #{{{
  def load_dependencies
    @conf[:dependencies][:deps] = Psych.load_file @conf[:dependencies][:file]
  end
  #}}}

  #{{{
  def load_classpaths
      @conf[:classpath][:modules] = Psych.load_file @conf[:classpath][:file]
  end
  #}}}

  def find_all_sources
  end

  def find_all_test_sources
  end

  ##
  # Initialize clide by parsing the pom and storing the data in the .clide directory
  #{{{
  def init
    # grab the project root pom
    root_pom = Pom.new(@conf[:project_root] + "pom.xml")
    # generate and load the effective pom and extract data from it so we don't need to parse it everytime
    @pom = load_effective_pom @conf


    # calculate the md5 hash of every pom and store it if needed
    if @conf.poms_have_been_updated?
      @conf[:pom_md5].open('w+') { |file| file.puts @pom.pom_md5s }
      update_dependencies
      generate_classpaths
    else
      load_dependencies
      load_classpaths
    end
  end
  #}}}

  #{{{
  def Clide.help(args = nil)
    puts "Unknown command:  #{args}" unless args == nil
    puts "Usage:  clide [options] [command [arguments]]"
    puts "  Options:"
    puts "    -s        have source files been updated? exit code: 0 = yes, 1 = no"
    puts "    -d        have dependencies been updated? exit code: 0 = yes, 1 = no"
    puts 
    puts "  All available commands have additional help, use 'clide <cmd> help'"
    puts "  Available Commands:"
    puts "    help:     display this message"
    puts "    init:     initialize project"
    puts "    imports:  list imports"
    puts "    deps:     list dependencies"
    puts "    update:   update/reinitialize project"
  end
  #}}}

  #{{{
  def list_deps(prj_name = Pathname::pwd.basename)
    puts prj_name
    puts 
  end
  #}}}

  #{{{
  def compile
    # did any files change?
    #   no: exit
    # did deps change?
    #   yes: update_dependencies
    # for each module with file changes
    #   compile changed files
  end
  #}}}


  #{{{
  def run(args)
    opt_parser = OptionParser.new { |opts|
      opts.on('-s', '--updated-sources', 'have source files been updated? exit code: 0 = yes, 1 = no') { |opt|
        puts "Not Implemented.  -s will exit with a status of 0 if sources have changed, non-zero otherwise"
        exit 1
      }

      opts.on('-d', '--updated-dependencies', 'have dependencies been changed? exit code: 0 = yes, 1 = no') { |opt|
        puts "Not Implemented.  -d will exit with a status of 0 is dependencies have changed, non-zero otherwise"
        exit 1
      }
    }
    opt_parser.parse!

    command = args.shift

    case command
    when 'init', 'update', 'up', 'refresh'
      init
    when 'imports', 'imp'
      #gen_imports args
      raise "Not implemented!"
    when 'deps'
      #list_deps
      raise "Not implemented!"
    when 'help'
      Clide.help
    else
      Clide.help command
    end
  end
  #}}}
end
#}}}


begin
  Clide.new.run(ARGV)
rescue
  puts $!
  puts $!.backtrace
  Clide.help
end
